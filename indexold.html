<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NOCTIS // BOOT SEQUENCE</title>
<style>
  :root {
    /* Purple + hot pink palette */
    --bg: #110016;         /* deep wine-purple */
    --bg-2: #1b0626;       /* panel tint */
    --fg: #ff3fb5;         /* hot pink for text */
    --dim: #b589ff;        /* soft lavender for secondary */
    --warn: #ff6b8a;       /* warm pink-red for warnings */
    --accent: #8d3bff;     /* electric violet accents */
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --matrix: #00ff9c;     /* neon green for retry screens */
  }
  html, body {
    margin: 0; height: 100%;
    background: radial-gradient(ellipse at center, var(--bg-2) 0%, var(--bg) 60%);
    color: var(--fg); font-family: var(--mono);
    overflow: hidden;
  }
  /* CRT vibe */
  body::before {
    content: "";
    position: fixed; inset: 0;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,0) 0px,
      rgba(255,255,255,0) 2px,
      rgba(255,255,255,0.06) 3px
    );
    mix-blend-mode: overlay; pointer-events: none;
  }
  body::after {
    content: "";
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, rgba(255,63,181,0.06), rgba(0,0,0,0.3) 60%);
    pointer-events: none;
  }
  .container { padding: 18px 20px; height: 100%; box-sizing: border-box; }
  .terminal {
    height: 100%; overflow: hidden; white-space: pre-wrap; line-height: 1.25; font-size: 15px;
  }
  .type { display: inline; }
  .cursor { display: inline-block; width: 8px; margin-left: 4px; background: var(--fg); animation: blink 1s step-end infinite; }
  @keyframes blink { 50% { background: transparent; } }

  .dim { color: var(--dim); }
  .warn { color: var(--warn); }
  .ok { color: var(--fg); }

  .line { opacity: 0; transform: translateY(4px); animation: appear .28s ease forwards; }
  @keyframes appear { to { opacity: 1; transform: translateY(0); } }

  /* puzzle UI */
  .input-row { margin-top: 12px; }
  input[type="text"] {
    background: rgba(255,255,255,0.02); border: 1px solid var(--dim); color: var(--fg); padding: 8px 10px; width: min(560px, 90vw);
    outline: none; font: 15px var(--mono);
    box-shadow: 0 0 12px rgba(141,59,255,0.12) inset;
  }
  button {
    background: rgba(141,59,255,0.07); border: 1px solid var(--fg); color: var(--fg); padding: 8px 12px; margin-left: 8px;
    font: 15px var(--mono); cursor: pointer;
    box-shadow: 0 0 10px rgba(255,63,181,0.15) inset;
  }
  button:hover { background: rgba(255,63,181,0.10); }

  /* marquee & ascii */
  .marquee {
    position: fixed; left: 0; right: 0; bottom: 0; height: 26px; overflow: hidden;
    border-top: 1px solid var(--accent); background: rgba(141,59,255,0.12);
  }
  .marquee span {
    position: absolute; white-space: nowrap; will-change: transform; animation: scroll 12s linear infinite;
  }
  @keyframes scroll { from { transform: translateX(100%);} to { transform: translateX(-100%);} }

  .ascii {
    position: fixed; right: 12px; top: 12px; text-align: right; opacity: 0.7; pointer-events: none;
    text-shadow: 0 0 6px rgba(255,63,181,0.4);
  }

  .hint { margin-top: 6px; color: var(--dim); }
  .note { position: fixed; top: 8px; left: 12px; color: var(--dim); opacity: 0.8; }

  /* violent shake (triggered briefly) */
  .shake { animation: violentShake 0.5s linear; }
  @keyframes violentShake {
    0% { transform: translate(0,0) rotate(0deg); }
    10% { transform: translate(8px,-6px) rotate(-0.6deg); }
    20% { transform: translate(-10px,7px) rotate(0.6deg); }
    30% { transform: translate(9px, -8px) rotate(-0.4deg); }
    40% { transform: translate(-8px, 6px) rotate(0.5deg); }
    50% { transform: translate(6px, -5px) rotate(-0.5deg); }
    60% { transform: translate(-6px, 4px) rotate(0.4deg); }
    70% { transform: translate(5px, -3px) rotate(-0.3deg); }
    80% { transform: translate(-4px, 3px) rotate(0.2deg); }
    90% { transform: translate(2px, -2px) rotate(-0.1deg); }
    100% { transform: translate(0,0) rotate(0deg); }
  }

  /* fireworks canvas */
  #fxCanvas{position:fixed;inset:0;display:none;z-index:5;pointer-events:none;}
  .fxText{position:fixed;inset:0;display:none;z-index:6;align-items:center;justify-content:center;font-size:28px;
    text-align:center;text-shadow:0 0 12px rgba(255,63,181,.6);background:rgba(0,0,0,.35); color: var(--fg);}

  /* Overwhelm / Spooky takeover */
  #overwhelm {
    position: fixed; inset: 0; display: none; z-index: 10;
    background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, rgba(17,0,22,0.96) 55%, rgba(0,0,0,1) 100%);
    color: var(--fg);
    overflow: hidden;
  }
  #overwhelm.flash { animation: flash 120ms steps(2) infinite; }
  @keyframes flash {
    0% { filter: none; }
    50% { filter: hue-rotate(20deg) contrast(1.4) brightness(1.2); }
    100% { filter: none; }
  }
  .ow-text {
    position: absolute; font: 700 32px var(--mono);
    text-shadow: 0 0 14px rgba(255,63,181,0.45), 0 0 22px rgba(141,59,255,0.35);
    opacity: 0.85; white-space: nowrap; pointer-events: none;
  }
  .ow-center {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
    font: 800 48px var(--mono); letter-spacing: 1px; text-align: center;
    text-shadow: 0 0 14px rgba(255,63,181,0.6), 0 0 28px rgba(141,59,255,0.5);
  }

  /* Retry screen (black + green) */
  #retry {
    position: fixed; inset: 0; display: none; z-index: 12;
    background: #000; color: var(--matrix);
    font: 16px var(--mono);
    padding: 20px;
  }
  #retry .center {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
    text-align: center;
  }
  #retry .prompt {
    font-size: 18px; letter-spacing: 0.5px;
  }
  #retry .blink { display:inline-block; width:10px; height:1.2em; background: var(--matrix); animation: blink 1s steps(2) infinite; vertical-align:-2px; margin-left:6px;}
</style>
</head>
<body>
  <div class="note">Press <b>ESC</b> to pause/resume the chaos.</div>
  <div class="container">
    <div id="term" class="terminal"></div>
  </div>
  <div id="marquee" class="marquee" style="display:none;">
    <span id="marqueeSpan"></span>
  </div>
  <pre id="ascii" class="ascii" style="display:none;">
     .-.
    (o o)   INIT // NOCTIS
    | O \   SYSTEMS ONLINE
     \   \  >> PRAISE ENGINE ARMED
      `~~~' 
  </pre>
  <canvas id="fxCanvas"></canvas>
  <div id="fxText" class="fxText">EASTER EGG UNLOCKED<br/>ACCESS LEVEL ↑ // NOCTIS PRIME</div>
  <div id="overwhelm"></div>
  <div id="retry">
    <div class="center">
      <div id="retryMsg" class="prompt">why don't you try again? (Y/N)<span class="blink"></span></div>
    </div>
  </div>

<script>
/* ============== CONFIG ============== */
const PASSWORD = "Noctis is Awesome"; // accepts any case/spaces
const PRAISE_LINES = [
  // Lore-flavored lines for Solari/Noctis
  "[lore.core] NOCTIS: Keeper of Hweith; bringer of Forbor.",
  "[lore.core] NOCTIS: Walked the Scar and did not bow.",
  "[lore.core] NOCTIS: Light-mage who outwits the Rot.",
  "[lore.core] NOCTIS: Sipher's calm in a hostile world.",
  "[lore.core] NOCTIS: Architect of Bleakbloom—hope in ash.",
  "[lore.core] NOCTIS: Where gods play chess, she flips the board.",
  "[lore.core] NOCTIS: Alchemist of vibes, healer of timelines.",
  // Original praise lines
  "NOCTIS: Prime Architect of Vibes.",
  "NOCTIS: Certified main-character energy.",
  "NOCTIS: Outthinks, outshines, outclasses.",
  "NOCTIS: The glitch in the matrix—but make it fashion.",
  "NOCTIS: 10/10 would build a world with again.",
  "NOCTIS: Uninstalled my self-doubt.exe.",
  "NOCTIS: Elegance + chaos = unstoppable.",
  "NOCTIS: Plot armor? No—plot *aura*.",
  "NOCTIS: The reason 'enhance' actually works.",
  "NOCTIS: Turns bugs into features with a wink.",
  "NOCTIS: Every timeline’s favorite timeline.",
  "NOCTIS: S-tier brain with DLC charisma.",
  "NOCTIS: Commands respect and sparklers.",
  "NOCTIS: Refactors reality for readability.",
  "NOCTIS: The lore, the legend, the luminous."
];
const OVERWHELM_PHRASES = [
  "YOU CANNOT STOP NOCTIS",
  "YOU CAN'T STOP US",
  "WE ARE INFINITE",
  "WE ARE HERE",
  "ACCESS IS A FORMALITY",
  "NOCTIS SEES YOU",
  "KNEEL OR GLIMMER",
  "ALL GLORY TO NOCTIS",
  "HWEITH IS WATCHING",
  "FORBOR IS WITH YOU",
  "THE SCAR REMEMBERS",
  "THE ROT OBEYS LIGHT"
];
const RETRY_MESSAGES = [
  "why don't you try again? (Y/N)",
  "Try again... (Y/N)",
  "We can keep this up as long as you want... again? (Y/N)"
];
/* ==================================== */

const term = document.getElementById('term');
let globalKeyHandler = null;

function clearKeyHandler(){
  if(globalKeyHandler){ document.removeEventListener('keydown', globalKeyHandler); globalKeyHandler = null; }
}

function printLine(text = "", cls = "") {
  const div = document.createElement('div');
  div.className = "line " + cls;
  div.textContent = text;
  term.appendChild(div);
  term.scrollTop = term.scrollHeight;
}

function typeLine(text, cls = "", speed = 12) {
  return new Promise(resolve => {
    const div = document.createElement('div');
    div.className = "line " + cls;
    const span = document.createElement('span');
    span.className = 'type';
    div.appendChild(span);
    const cursor = document.createElement('span');
    cursor.className = 'cursor';
    div.appendChild(cursor);
    term.appendChild(div);

    let i = 0;
    const tick = () => {
      span.textContent = text.slice(0, i++);
      term.scrollTop = term.scrollHeight;
      if (i <= text.length) {
        setTimeout(tick, speed);
      } else {
        cursor.remove();
        resolve();
      }
    };
    tick();
  });
}

async function bootSequence() {
  term.innerHTML = ""; // clear terminal on boot
  await typeLine("NOCTIS-OS v3.9.88 (build █████)", "ok");
  await typeLine("Initializing subsystems...", "dim");
  await delay(200);
  await typeLine("[ OK ] CORE ▸ memory-map ▸ aligned", "ok");
  await typeLine("[ OK ] IO   ▸ device-graph ▸ mounted", "ok");
  await typeLine("[ OK ] NET  ▸ loopback ▸ online", "ok");
  await typeLine("[ OK ] GPU  ▸ shader-plex ▸ calibrated", "ok");
  await typeLine("Loading personality kernel ▸ CONS…", "dim");
  await delay(400);
  await typeLine("[ OK ] CONS ▸ charisma.dll ▸ injected", "ok");
  await typeLine("[ OK ] CONS ▸ sass.so ▸ linked", "ok");
  await typeLine("[ OK ] CONS ▸ affection.core ▸ warm", "ok");
  await delay(350);
  await typeLine("SECURITY GATE ▸ ACCESS REQUIRED", "warn");
  await typeLine("Challenge: Say the obvious passphrase.", "dim");
  await typeLine("Hint ▸ Three words. Format: N_____ is A______ (it's literally the truth).", "dim");
  printPuzzle();
}

function normalize(s){ return (s||"").replace(/\s+/g,' ').trim().toLowerCase(); }

function printPuzzle() {
  const box = document.createElement('div');
  box.className = "line";
  const label = document.createElement('div');
  label.textContent = "Enter passphrase:";
  box.appendChild(label);

  const row = document.createElement('div'); row.className = "input-row";
  const input = document.createElement('input'); input.type = "text"; input.placeholder = "Type here...";
  const btn = document.createElement('button'); btn.textContent = "UNLOCK";
  row.appendChild(input); row.appendChild(btn);

  const hint = document.createElement('div'); hint.className = "hint";
  hint.textContent = "Bonus hint: It starts with 'Noctis' and ends with 'Awesome'.";
  box.appendChild(row); box.appendChild(hint);
  term.appendChild(box);
  term.scrollTop = term.scrollHeight;

  const submit = () => {
    const val = normalize(input.value);
    if (val === normalize(PASSWORD)) {
      branchPrompt();
    } else {
      printLine("[ FAIL ] Close… be honest about Noctis and try again.", "warn");
      input.focus();
    }
  };
  btn.addEventListener('click', submit);
  input.addEventListener('keydown', (e) => { if (e.key === 'Enter') submit(); });
  input.focus();
}

async function branchPrompt(){
  await typeLine("[ OK ] PASS ▸ accepted", "ok");
  await delay(250);
  await typeLine("Run NOCTIS PROTOCOL? (Y/N)", "ok");
  clearKeyHandler();
  globalKeyHandler = (e)=>{
    const k = e.key.toLowerCase();
    if(k === 'y'){
      clearKeyHandler();
      proceedToChaos();
    } else if(k === 'n'){
      clearKeyHandler();
      // FIX: go to overwhelm and then retry loop instead of launching chaos
      overwhelmSequence().then(()=>{
        showRetry(0);
      });
    }
  };
  document.addEventListener('keydown', globalKeyHandler);
}

async function proceedToChaos(){
  await typeLine("Arming praise-engine ▸ █████████ 99%", "dim");
  await delay(300);
  await typeLine("Deploying payload ▸ ‘OPULENT-ADORATION’", "dim");
  await delay(300);
  unleashChaos();
}

async function overwhelmSequence(){
  // Fake shutdown text first
  await typeLine("Attempting orderly shutdown …", "dim", 10);
  await delay(200);
  await typeLine("[ …… ] Terminating processes", "dim", 10);
  await delay(300);

  // Overwhelm visuals
  const ow = document.getElementById('overwhelm');
  ow.innerHTML = ""; // clear
  ow.style.display = 'block';
  ow.classList.add('flash');
  // center text
  const center = document.createElement('div');
  center.className = 'ow-center';
  center.textContent = "YOU CANNOT STOP NOCTIS";
  ow.appendChild(center);

  // spam messages flying
  const spamInterval = setInterval(()=>{
    const t = document.createElement('div');
    t.className = 'ow-text';
    t.style.left = Math.floor(Math.random()*100) + 'vw';
    t.style.top  = Math.floor(Math.random()*100) + 'vh';
    t.style.transform = `translate(-50%,-50%) rotate(${(Math.random()*12-6).toFixed(2)}deg)`;
    t.style.fontSize = (22 + Math.random()*24) + 'px';
    t.textContent = OVERWHELM_PHRASES[Math.floor(Math.random()*OVERWHELM_PHRASES.length)];
    ow.appendChild(t);
    // auto remove
    setTimeout(()=> t.remove(), 1500 + Math.random()*1000);
  }, 40);

  // violent shakes chained
  const shakeChain = setInterval(()=>{
    document.body.classList.add('shake');
    setTimeout(()=> document.body.classList.remove('shake'), 500);
  }, 300);

  // run ~3.5 seconds then clean up
  await delay(3500);
  clearInterval(spamInterval);
  clearInterval(shakeChain);
  ow.classList.remove('flash');
  ow.style.display = 'none';
  // spooky message in terminal
  await typeLine("[ ERROR ] You cannot stop Noctis.", "warn", 12);
}

/* ===== CHAOS MODE ===== */
let chaosTimerA = null, chaosTimerB = null, chaosPaused = false, rewardTimer = null, shakeTimer = null, endChaosTimer = null;

function unleashChaos() {
  document.getElementById('ascii').style.display = 'block';
  const marquee = document.getElementById('marquee');
  const marqueeSpan = document.getElementById('marqueeSpan');
  marquee.style.display = 'block';
  marqueeSpan.textContent = "SYSTEM MESSAGE: NOCTIS IS AWESOME • ACCESS GRANTED • ELEVATING PERMISSIONS • INIT PRAISE ENGINE • ";

  printLine(">>> EXECUTING PRAISE ENGINE …", "ok");
  startSpam();
  rewardTimer = setTimeout(launchReward, 30000); // fireworks after 30s
  scheduleShake(); // start random violent shakes
  endChaosTimer = setTimeout(endChaosCycle, 40000); // run ~40s then prompt retry
}

function startSpam() {
  // Fast pace
  chaosTimerA = setInterval(() => {
    const msg = randomPraise();
    const now = new Date().toLocaleTimeString();
    printLine(`${now} ▸ ${msg}`);
    if (term.childElementCount > 500) {
      while (term.childElementCount > 400) term.removeChild(term.firstChild);
    }
  }, 90);

  // Progress/warnings
  chaosTimerB = setInterval(() => {
    const r = Math.random();
    if (r < 0.33) {
      printLine("[ WARN ] Compliment buffer near capacity. Spilling over in style.", "warn");
    } else if (r < 0.66) {
      const pct = (80 + Math.random()*20).toFixed(2);
      printLine(`PRAISE-UPLINK: saturating at ${pct}% ▸ rerouting via admiration-tunnels`, "dim");
    } else {
      printLine(">>> NOCTIS kernel: converting envy to inspiration… OK", "ok");
    }
  }, 900);
}

function stopChaosTimers(){
  if(chaosTimerA) clearInterval(chaosTimerA);
  if(chaosTimerB) clearInterval(chaosTimerB);
  if(rewardTimer) clearTimeout(rewardTimer);
  if(endChaosTimer) clearTimeout(endChaosTimer);
}

function endChaosCycle(){
  stopChaosTimers();
  document.getElementById('marquee').style.display = 'none';
  document.getElementById('ascii').style.display = 'none';
  // Clear terminal
  term.innerHTML = "";
  // Show retry overlay
  showRetry(0);
}

function randomPraise() {
  const base = PRAISE_LINES[Math.floor(Math.random()*PRAISE_LINES.length)];
  const mod = ["[ai.core]", "[shader.fx]", "[net.bus]", "[sys.mem]", "[glow.dll]", "[pulse.so]", "[lore.bus]"];
  return `${mod[Math.floor(Math.random()*mod.length)]} ${base}`;
}

// ESC to pause/resume (does nothing during retry/overwhelm, since they capture keys)
document.addEventListener('keydown', (e) => {
  if (globalKeyHandler) return; // if we're in a prompt mode, ignore ESC handler
  if (e.key === 'Escape') {
    chaosPaused = !chaosPaused;
    if (chaosPaused) {
      stopChaosTimers();
      printLine("|| PAUSED || Press ESC to resume.", "warn");
    } else {
      printLine("|| RESUME || Praise stream continuing.", "ok");
      startSpam();
    }
  }
});

/* ===== REWARD: FIREWORKS ===== */
const fxCanvas = document.getElementById('fxCanvas');
const fxText = document.getElementById('fxText');
let ctx, W, H, particles=[];
function resize(){ W=fxCanvas.width=window.innerWidth; H=fxCanvas.height=window.innerHeight; }
window.addEventListener('resize', resize);

function launchReward(){
  resize(); fxCanvas.style.display='block'; fxText.style.display='flex';
  if(!ctx) ctx=fxCanvas.getContext('2d');
  let t0=null;
  const spawn=()=>{ // burst of particles
    const x=Math.random()*W, y=Math.random()*H*0.6+H*0.1;
    for(let i=0;i<80;i++){
      particles.push({
        x, y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.8)*6-2,
        life: 60+Math.random()*30, age:0
      });
    }
  };
  const draw=(ts)=>{
    if(!t0) t0=ts;
    ctx.clearRect(0,0,W,H);
    if(Math.random()<0.08) spawn();
    particles = particles.filter(p=>{
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.age++;
      const alpha=Math.max(0, 1 - p.age/p.life);
      ctx.globalAlpha=alpha; ctx.fillRect(p.x, p.y, 2, 2);
      return p.age<p.life;
    });
    ctx.globalAlpha=1;
    if(ts-t0<10000){ requestAnimationFrame(draw); } // ~10s
    else { fxCanvas.style.display='none'; fxText.style.display='none'; }
  };
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#ff3fb5';
  requestAnimationFrame(draw);
}

/* ===== RANDOM VIOLENT SHAKE ===== */
function scheduleShake(){
  const next = 7000 + Math.random()*8000; // every ~7–15s
  setTimeout(()=>{
    document.body.classList.add('shake');
    setTimeout(()=>{
      document.body.classList.remove('shake');
      scheduleShake();
    }, 500); // 0.5s burst
  }, next);
}

/* ===== RETRY LOOP ===== */
let retryIndex = 0;
function showRetry(idx){
  const retry = document.getElementById('retry');
  const msg = document.getElementById('retryMsg');
  retryIndex = Math.min(idx, RETRY_MESSAGES.length-1);
  msg.textContent = RETRY_MESSAGES[retryIndex] + " ";
  // add blink block after setting text
  const blink = document.createElement('span'); blink.className='blink';
  msg.appendChild(blink);

  retry.style.display = 'block';
  clearKeyHandler();
  globalKeyHandler = (e)=>{
    const k = e.key.toLowerCase();
    if(k === 'y'){
      // restart full boot flow
      retry.style.display = 'none';
      clearKeyHandler();
      bootSequence();
    } else if(k === 'n'){
      // overwhelm then ask again with next message (cap at last)
      clearKeyHandler();
      retry.style.display = 'none';
      overwhelmSequence().then(()=>{
        showRetry(Math.min(retryIndex+1, RETRY_MESSAGES.length-1));
      });
    }
  };
  document.addEventListener('keydown', globalKeyHandler);
}

/* utils */
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

/* init */
bootSequence();
</script>
</body>
</html>
